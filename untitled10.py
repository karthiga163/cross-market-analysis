# -*- coding: utf-8 -*-
"""Untitled10.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ex_vUHu9b9R0a1zallIt6JEhcssviqMn
"""

all_records = []
import requests


base_url="https://api.coingecko.com/api/v3/coins/markets?vs_currency=inr&per_page=250&order=market_cap_desc&page={}&sparkline=False"
for page_num in range(1,6):
    url  = f"https://api.coingecko.com/api/v3/coins/markets?vs_currency=inr&per_page=250&order=market_cap_desc&page={page_num}&sparkline=False"
    print(f"new url: {url}")
    response = requests.get(url)
    if response.status_code == 200:
        data = response.json()
        all_records.extend(data)

from google.colab import drive
drive.mount('/content/drive')

data

records = []
for i in all_records:
  records.append(dict(id = i['id'],
                      symbol=i['symbol'],
                      name=i['name'],
                      rank=i['market_cap_rank'],
                      current_price=i['current_price'],
                      market_cap=i['market_cap'],
                      total_volume=i['total_volume'],
                      circulating_supply=i['circulating_supply'],
                      total_supply=i['total_supply'],
                      ath=i['ath'],
                      atl=i['atl'],
                      ath_date=i['ath_date'],
                      last_updated=i['last_updated']))

records

import pandas as pd
coins_df = pd.DataFrame(records)
coins_df['date']=pd.to_datetime(coins_df['last_updated']).dt.date
del coins_df['last_updated']
display(coins_df.head())

coins_df

#Top 3 coins - Historical prices

import requests
import pandas as pd

historical_data = []

coin_ids = ['bitcoin','ethereum','tether']
for coin_id in coin_ids:
    url=f"https://api.coingecko.com/api/v3/coins/{coin_id}/market_chart?vs_currency=USD&days=365"
    response = requests.get(url)
    if response.status_code == 200:
        data = response.json()
        if 'prices' in data:
            df = pd.DataFrame(data['prices'], columns=['date', 'price'])
            df['date'] = pd.to_datetime(df['date'], unit='ms')
            df['coin_name'] = coin_id
            historical_data.append(df)
        else:
            print(f"Warning: 'prices' key not found in data for {coin_id}. Response: {data}")
    else:
        print(f"Error fetching data for {coin_id}: Status Code {response.status_code}, Response: {response.text}")

if historical_data:
    top_df = pd.concat(historical_data, ignore_index=True)
    print("Historical data collected successfully.")
    print(top_df)
else:
    print("No historical data collected due to API errors.")
    top_df = pd.DataFrame() # Initialize top_df as an empty DataFrame if no data is collected

import pandas as pd
oils_df = pd.read_csv("https://raw.githubusercontent.com/datasets/oil-prices/main/data/wti-daily.csv")
oils_df

oils_df['Date']=pd.to_datetime(oils_df['Date'])

oils_df.info()

filtered_prices = oils_df.loc[(oils_df['Date'] >= '2020-01-01') & (oils_df['Date'] <= '2026-01-26'),['Date','Price']]

filtered_prices

import yfinance as yf
import pandas as pd

tickers=["^GSPC", "^IXIC", "^NSEI"]
start_date = "2020-01-01"
end_date = "2026-01-26"

stock_df = yf.download(tickers, start=start_date, end=end_date, group_by='ticker')
stock_df = stock_df.reset_index() # Convert the Date index to a regular column

stock_df

stock_df["^IXIC"].reset_index()

stock_df.dropna()

stock_df

import sqlite3

conn = sqlite3.connect("mydb.db")
cursor = conn.cursor()

# Drop the existing Cryptocurrency table if it exists to ensure a fresh schema
cursor.execute("DROP TABLE IF EXISTS Cryptocurrency;")
conn.commit()

create_table_sql = """
CREATE TABLE Cryptocurrency (
    id VARCHAR(50) PRIMARY KEY,
    symbol VARCHAR(10),
    name VARCHAR(100),
    current_price DECIMAL(18, 6),
    market_cap BIGINT,
    market_cap_rank INT,
    total_volume  BIGINT,
    circulating_supply DECIMAL(20, 6),
    total_supply DECIMAL(20, 6),
    ath DECIMAL(18, 6),
    atl DECIMAL(18, 6),
    ath_date DATE,
    date DATE
);
"""

# Execute the table creation command
cursor.execute(create_table_sql)
conn.commit() # Commit the transaction

# Rename the 'rank' column to 'market_cap_rank' if it still exists in coins_df (idempotent)
if 'rank' in coins_df.columns:
    coins_df = coins_df.rename(columns={'rank': 'market_cap_rank'})

# Now insert the data into the freshly created table
coins_df.to_sql('Cryptocurrency', conn, if_exists='append', index=False)
print("Content of 'coins_df' successfully inserted into 'Cryptocurrency' table.")

create_table_sql = """
CREATE TABLE  "Crypto prices" (
    date DATE,
    price DECIMAL(18, 6),
    coin_name VARCHAR(50)
);
"""
cursor.execute("DROP TABLE IF EXISTS \"Crypto prices\";") # Explicitly drop the table
cursor.execute(create_table_sql)
conn.commit()
top_df.to_sql('Crypto prices', conn, if_exists='append', index=False) # Use append after explicit create
print("Content of 'top_df' successfully inserted into 'Crypto prices' table.")

create_table_sql = """
CREATE TABLE  "oil prices" (
    date DATE PRIMARY KEY,
    price_usd DECIMAL(18, 6)
);
"""
cursor.execute(create_table_sql)
conn.commit()
filtered_prices.to_sql('oil prices', conn, if_exists='replace', index=False)
print("Content of 'top_df' successfully inserted into 'oil prices' table.")

create_table_sql = """
CREATE TABLE  "stock prices" (
    "('Date', '')" DATE,
    "('^NSEI', 'Open')" DECIMAL(18, 6),
    "('^NSEI', 'High')" DECIMAL(18, 6),
    "('^NSEI', 'Low')" DECIMAL(18, 6),
    "('^NSEI', 'Close')" DECIMAL(18, 6),
    "('^NSEI', 'Volume')" BIGINT,
    "('^GSPC', 'Open')" DECIMAL(18, 6),
    "('^GSPC', 'High')" DECIMAL(18, 6),
    "('^GSPC', 'Low')" DECIMAL(18, 6),
    "('^GSPC', 'Close')" DECIMAL(18, 6),
    "('^GSPC', 'Volume')" BIGINT,
    "('^IXIC', 'Open')" DECIMAL(18, 6),
    "('^IXIC', 'High')" DECIMAL(18, 6),
    "('^IXIC', 'Low')" DECIMAL(18, 6),
    "('^IXIC', 'Close')" DECIMAL(18, 6),
    "('^IXIC', 'Volume')" BIGINT
);
"""

cursor.execute("DROP TABLE IF EXISTS \"stock prices\";") # Drop the table first
cursor.execute(create_table_sql)
conn.commit()
stock_df.to_sql('stock prices', conn, if_exists='append', index=False) # Use append after explicit create
print("Content of 'stock_df' successfully inserted into 'stock prices' table.")

sql_query = """
SELECT id, name, market_cap_rank, market_cap
FROM Cryptocurrency
ORDER BY market_cap DESC
LIMIT 3;
"""
top_3_coins = pd.read_sql_query(sql_query, conn)
display(top_3_coins)

sql_query = """
SELECT id, name, symbol, circulating_supply, total_supply
FROM Cryptocurrency
WHERE circulating_supply > (total_supply * 0.9)
ORDER BY name;
"""
circulating_supply_coins = pd.read_sql_query(sql_query, conn)
display(circulating_supply_coins)

sql_query = """
SELECT id, name, symbol, current_price, ath
FROM Cryptocurrency
WHERE current_price >= ath * 0.9;
"""

within_10_percent_ath_coins = pd.read_sql_query(sql_query, conn)
print("Cryptocurrencies within 10% of their All-Time High:")
display(within_10_percent_ath_coins)

sql_query = """
SELECT AVG(market_cap_rank)
FROM Cryptocurrency
WHERE total_volume > 1000000000;
"""
average_market_cap_rank = pd.read_sql_query(sql_query, conn)
print("Average market cap rank for cryptocurrencies with total_volume > 1,000,000,000:")
display(average_market_cap_rank)

sql_query = """
SELECT *
FROM Cryptocurrency
ORDER BY date DESC
LIMIT 1;
"""
most_recent_coin = pd.read_sql_query(sql_query, conn)
display(most_recent_coin)

sql_query = """
SELECT * FROM "crypto prices"
WHERE coin_name = 'bitcoin'
ORDER BY price DESC
LIMIT 1;
"""
highest_priceofbitcoin= pd.read_sql_query(sql_query, conn)
print("highest_priceofbitcoin:")
display(highest_priceofbitcoin)

max_timestamp_query = """
SELECT MAX(date) FROM "Crypto prices"
"""
max_timestamp = pd.read_sql_query(max_timestamp_query, conn).iloc[0, 0]
max_timestamp = pd.to_datetime(max_timestamp)

one_year_ago = max_timestamp - pd.DateOffset(years=1)

sql_query = f"""
SELECT AVG(price)
FROM "Crypto prices"
WHERE coin_name = 'ethereum'
AND date >= '{one_year_ago.strftime('%Y-%m-%d %H:%M:%S')}';
"""

ethereum_avg_price_past_year = pd.read_sql_query(sql_query, conn)
print("Average price of Ethereum for the past 1 year:")
display(ethereum_avg_price_past_year)

sql_query = """
SELECT date, price
FROM "Crypto prices"
WHERE coin_name = 'bitcoin'
AND date BETWEEN '2025-02-01 00:00:00' AND '2025-02-31 23:59:59'
ORDER BY date;
"""

bitcoin_feb_2025_prices = pd.read_sql_query(sql_query, conn)
display(bitcoin_feb_2025_prices)

sql_query = """
SELECT coin_name, AVG(price) FROM "Crypto prices"
GROUP BY coin_name
ORDER BY AVG(price) DESC
LIMIT 1;
"""
highest_price  = pd.read_sql_query(sql_query, conn)
display(highest_price)

sql_query_start = """
SELECT price
FROM "Crypto prices"
WHERE coin_name = 'bitcoin'
AND date BETWEEN '2025-09-01 00:00:00' AND '2025-09-01 23:59:59'
ORDER BY date ASC
LIMIT 1;
"""

sql_query_end = """
SELECT price
FROM "Crypto prices"
WHERE coin_name = 'bitcoin'
  AND date BETWEEN '2025-09-30 00:00:00' AND '2025-09-30 23:59:59'
ORDER BY date DESC
LIMIT 1;
"""

start_price_df = pd.read_sql_query(sql_query_start, conn)
end_price_df = pd.read_sql_query(sql_query_end, conn)

if not start_price_df.empty and not end_price_df.empty:
    start_price = start_price_df['price'].iloc[0]
    end_price = end_price_df['price'].iloc[0]

    percentage_change = ((end_price - start_price) / start_price) * 100
    print(f"Bitcoin price at the beginning of September 2025: {start_price:,.2f} INR")
    print(f"Bitcoin price at the end of September 2025: {end_price:,.2f} INR")
    print(f"Percentage change in Bitcoin's price during September 2025: {percentage_change:,.2f}%")
else:
    print("Data for Bitcoin in September 2025 is not available.")

sql_query = """
SELECT * FROM "oil prices" where date between '2020-02-01' and '2026-01-01'
order by Price desc
limit 1 ;
"""
highest_oilprice  = pd.read_sql_query(sql_query, conn)
display(highest_oilprice)

sql_query = """
SELECT STRFTIME('%Y', Date) AS year, AVG(Price) AS average_price
FROM "oil prices"
GROUP BY year
ORDER BY year;
"""

average_oil_price_sql = pd.read_sql_query(sql_query, conn)
display(average_oil_price_sql)

sql_query = """
select * from "oil prices"
where date between '2020-03-01' and '2020-04-01'
order by date;
"""
covid_crash_prices = pd.read_sql_query(sql_query, conn)
display(covid_crash_prices)

sql_query = """
select * from "oil prices"
order by date
limit 1;
"""
lowoilprices = pd.read_sql_query(sql_query, conn)
display(lowoilprices)

sql_query_volatility = """
SELECT
    STRFTIME('%Y', Date) AS year,
    MAX(Price) AS max_price,
    MIN(Price) AS min_price,
    (MAX(Price) - MIN(Price)) AS price_difference
FROM "oil prices"
GROUP BY year
ORDER BY year;
"""

oil_price_volatility = pd.read_sql_query(sql_query_volatility, conn)
display(oil_price_volatility)

sql_query = """
select * from "stock prices";
"""
stock_price_ticker=pd.read_sql_query(sql_query, conn)
display(stock_price_ticker)

sql_query = """
SELECT MAX("('^IXIC', 'Close')")
FROM "stock prices"
ORDER BY ("('^IXIC', 'Close')") DESC
LIMIT 1;
"""

highest_nasdaq_close_price = pd.read_sql_query(sql_query, conn)
print("Highest NASDAQ Closing Price:")
display(highest_nasdaq_close_price)

sql_query = """
SELECT AVG("('^NSEI', 'Volume')")
FROM "stock prices"
WHERE STRFTIME('%Y', "('Date', '')") = '2024';
"""

average_nsei_volume_2024 = pd.read_sql_query(sql_query, conn)
print("Average trading volume of '^NSEI' in 2024:")
display(average_nsei_volume_2024)

sql_query = """
SELECT
    'Date',
    "^GSPC_High" AS GSPC_High,
    "^GSPC_Low" AS GSPC_Low,
    ("^GSPC_High" - "^GSPC_Low") AS Price_Difference
FROM "stock prices"
WHERE "^GSPC_High" IS NOT NULL AND "^GSPC_Low" IS NOT NULL
ORDER BY Price_Difference DESC
LIMIT 5;
"""

snap_top_5_gspc_volatility = pd.read_sql_query(sql_query, conn)
print("Top 5 days with highest price difference for S&P 500 (^GSPC):")
display(snap_top_5_gspc_volatility)

sql_query_fetch_stocks = """
SELECT
    "('Date', '')" AS Date,
    "('^GSPC', 'Close')" AS GSPC_Close,
    "('^IXIC', 'Close')" AS IXIC_Close,
    "('^NSEI', 'Close')" AS NSEI_Close
FROM "stock prices"
ORDER BY Date ASC;
"""
stock_prices_from_db = pd.read_sql_query(sql_query_fetch_stocks, conn)
stock_prices_from_db['Date'] = pd.to_datetime(stock_prices_from_db['Date'])
stock_prices_from_db = stock_prices_from_db.set_index('Date')

monthly_avg_closing_prices = stock_prices_from_db[['GSPC_Close', 'IXIC_Close', 'NSEI_Close']].resample('ME').mean()
print("Monthly Average Closing Prices:")
display(monthly_avg_closing_prices)

sql_query = """
SELECT
    cp.date,
    cp.price AS crypto_price,
    op.Price AS oil_price_usd
FROM "Crypto prices" AS cp
INNER JOIN "oil prices" AS op
ON cp.date = op.date
WHERE cp.coin_name = 'bitcoin';
"""
bitcoin_oil_price_correlation = pd.read_sql_query(sql_query, conn)
display(bitcoin_oil_price_correlation)

sql_query = """
SELECT
    cp.date AS crypto_date,
    cp.price AS bitcoin_price,
    sp."('Date', '')" AS stock_date,
    sp."('^GSPC', 'Close')" AS gspc_close
FROM "Crypto prices" AS cp
INNER JOIN "stock prices" AS sp
ON cp.date = sp."('Date', '')"
WHERE cp.coin_name = 'bitcoin';
"""

bitcoin_gspc_merged_df = pd.read_sql_query(sql_query, conn)
display(bitcoin_gspc_merged_df.head())
correlation = bitcoin_gspc_merged_df['bitcoin_price'].corr(bitcoin_gspc_merged_df['gspc_close'])
print(f"Pearson correlation coefficient between Bitcoin price and S&P 500 closing price: {correlation:.4f}")

sql_query = """
SELECT
    cp.date AS crypto_date,
    cp.price AS ethereum_price,
    sp."('Date', '')" AS stock_date,
    sp."('^IXIC', 'Close')" AS nasdaq_close
FROM "Crypto prices" AS cp
INNER JOIN "stock prices" AS sp
ON cp.date = sp."('Date', '')"
WHERE cp.coin_name = 'ethereum'
AND STRFTIME('%Y', cp.date) = '2025';
"""

ether_nasdaq_merged_df = pd.read_sql_query(sql_query, conn)
display(ether_nasdaq_merged_df.head())
correlation_ether_nasdaq = ether_nasdaq_merged_df['ethereum_price'].corr(ether_nasdaq_merged_df['nasdaq_close'])
print(f"Pearson correlation coefficient between Ethereum price and NASDAQ closing price in 2025: {correlation_ether_nasdaq:.4f}")

sql_query = """
SELECT
    op.Date AS date,
    cp.price AS bitcoin_price,
    op.Price AS oil_price_usd
FROM "oil prices" AS op
INNER JOIN "Crypto prices" AS cp
ON op.Date = cp.date
WHERE cp.coin_name = 'bitcoin';
"""

oil_bitcoin_merged_df = pd.read_sql_query(sql_query, conn)
display(oil_bitcoin_merged_df.head())

sql_query = """
SELECT
    cp.date AS date,
    MAX(CASE WHEN cp.coin_name = 'bitcoin' THEN cp.price END) AS bitcoin_price,
    MAX(CASE WHEN cp.coin_name = 'ethereum' THEN cp.price END) AS ethereum_price,
    MAX(CASE WHEN cp.coin_name = 'tether' THEN cp.price END) AS tether_price,
    sp."('^NSEI', 'Close')" AS nifty_close
FROM "Crypto prices" AS cp
INNER JOIN "stock prices" AS sp
ON cp.date = sp."('Date', '')"
WHERE cp.coin_name IN ('bitcoin', 'ethereum', 'tether')
GROUP BY cp.date, sp."('^NSEI', 'Close')"
ORDER BY cp.date;
"""

merged_crypto_nifty_df = pd.read_sql_query(sql_query, conn)
display(merged_crypto_nifty_df.head())

sql_query = """
SELECT
    sp."('Date', '')" AS date,
    sp."('^GSPC', 'Close')" AS gspc_close,
    op.Price AS oil_price
FROM "stock prices" AS sp
INNER JOIN "oil prices" AS op
ON sp."('Date', '')" = op.Date
WHERE STRFTIME('%Y-%m', sp."('Date', '')") = '2025-01';
"""

sp500_oil_2025_df = pd.read_sql_query(sql_query, conn)
display(sp500_oil_2025_df.head())

sql_query = """
SELECT
    cp.date AS date,
    cp.price AS bitcoin_price,
    op.Price AS oil_price_usd
FROM "Crypto prices" AS cp
INNER JOIN "oil prices" AS op
ON cp.date = op.date
WHERE cp.coin_name = 'bitcoin' AND STRFTIME('%Y-%m', cp.date) = '2025-02';
"""

bitcoin_oil_feb_2025_df = pd.read_sql_query(sql_query, conn)
display(bitcoin_oil_feb_2025_df.head())

if not bitcoin_oil_feb_2025_df.empty:
    correlation_bitcoin_oil_feb_2025 = bitcoin_oil_feb_2025_df['bitcoin_price'].corr(bitcoin_oil_feb_2025_df['oil_price_usd'])
    print(f"Pearson correlation coefficient between Bitcoin price and crude oil price for February 2025: {correlation_bitcoin_oil_feb_2025:.4f}")
else:
    print("No overlapping data for Bitcoin and crude oil prices in February 2025. Correlation cannot be calculated.")

sql_query = """
SELECT
    sp."('Date', '')" AS date,
    sp."('^IXIC', 'Close')" AS IXIC_close,
    op.Price AS ethereum_price
FROM "stock prices" AS sp
INNER JOIN "crypto prices" AS op
ON sp."('Date', '')" = op.Date
WHERE op.coin_name = 'ethereum';
"""
ether_nasdaq_merged_df = pd.read_sql_query(sql_query, conn)
display(ether_nasdaq_merged_df.head())

sql_query = """
SELECT
    cp.date AS date,
    MAX(CASE WHEN cp.coin_name = 'bitcoin' THEN cp.price END) AS bitcoin_price,
    MAX(CASE WHEN cp.coin_name = 'ethereum' THEN cp.price END) AS ethereum_price,
    MAX(CASE WHEN cp.coin_name = 'tether' THEN cp.price END) AS tether_price,
    sp."('^NSEI', 'Close')" AS nifty_close
FROM "Crypto prices" AS cp
INNER JOIN "stock prices" AS sp
ON cp.date = sp."('Date', '')"
WHERE cp.coin_name IN ('bitcoin', 'ethereum', 'tether')
AND STRFTIME('%Y', cp.date) = '2025'
GROUP BY cp.date, sp."('^NSEI', 'Close')"
ORDER BY cp.date;
"""

merged_crypto_nifty_2025_df = pd.read_sql_query(sql_query, conn)
display(merged_crypto_nifty_2025_df.head())

sql_query = """
SELECT
    sp."('Date', '')" AS date,
    sp."('^GSPC', 'Close')" AS gspc_close,
    op.Price AS oil_price,
    cp.price AS bitcoin_price
FROM "stock prices" AS sp
INNER JOIN "oil prices" AS op
ON sp."('Date', '')" = op.Date
INNER JOIN "Crypto prices" AS cp
ON sp."('Date', '')" = cp.date
WHERE cp.coin_name = 'bitcoin'
ORDER BY date;
"""

merged_stocks_oil_bitcoin_df = pd.read_sql_query(sql_query, conn)
display(merged_stocks_oil_bitcoin_df)

!pip install streamlit streamlit_option_menu  # installing streamlit and streamlit_option_menu packages

# Commented out IPython magic to ensure Python compatibility.
# %%writefile app.py
# 
# import streamlit as st
# from streamlit_option_menu import option_menu
# import pandas as pd
# import sqlite3
# 
# st.set_page_config(layout = 'wide')
# 
# st.title('Cross Market Analysis')
# 
# # Connect to the SQLite database
# conn = sqlite3.connect('mydb.db')
# 
# with st.sidebar:
#     select = option_menu('Main Menu', ['Home', 'MARKET OVERVIEW', 'SQL QUERY RUNNER', 'TOP COINS TREND ANALYSIS'])
# 
# if select == 'Home':
#     st.header('Welcome to the Cross Market Analysis Dashboard')
#     st.write('Use the sidebar to navigate through different analysis pages.')
# 
# elif select == 'MARKET OVERVIEW':
#     st.header('MARKET OVERVIEW: Filters & Data Exploration')
# 
#     # Date Range Selection
#     col1, col2 = st.columns(2)
#     with col1:
#         start_date = st.date_input('Start Date', pd.to_datetime('2020-01-01'))
#     with col2:
#         end_date = st.date_input('End Date', pd.to_datetime('2026-01-26'))
# 
#     if start_date > end_date:
#         st.error('Error: End Date must be after Start Date.')
#     else:
#         st.subheader(f'Data for the period: {start_date} to {end_date}')
# 
#         # Bitcoin Average Price
#         st.subheader('Average Prices')
#         sql_btc_avg = f"""
#         SELECT AVG(price) FROM "Crypto prices"
#         WHERE coin_name = 'bitcoin' AND date BETWEEN '{start_date}' AND '{end_date}'
#         """
#         avg_btc_price = pd.read_sql_query(sql_btc_avg, conn).iloc[0,0]
#         st.write(f"Average Bitcoin Price: ${avg_btc_price:,.2f}" if avg_btc_price else "N/A")
# 
#         # Oil Average Price
#         sql_oil_avg = f"""
#         SELECT AVG(Price) FROM "oil prices"
#         WHERE Date BETWEEN '{start_date}' AND '{end_date}'
#         """
#         avg_oil_price = pd.read_sql_query(sql_oil_avg, conn).iloc[0,0]
#         st.write(f"Average Oil Price: ${avg_oil_price:,.2f}" if avg_oil_price else "N/A")
# 
#         # S&P 500 Average Closing Price
#         sql_gspc_avg = f"""
#         SELECT AVG("('^GSPC', 'Close')") FROM "stock prices"
#         WHERE "('Date', '')" BETWEEN '{start_date}' AND '{end_date}'
#         """
#         avg_gspc_close = pd.read_sql_query(sql_gspc_avg, conn).iloc[0,0]
#         st.write(f"Average S&P 500 Closing Price: ${avg_gspc_close:,.2f}" if avg_gspc_close else "N/A")
# 
#         # NIFTY Average Closing Price
#         sql_nifty_avg = f"""
#         SELECT AVG("('^NSEI', 'Close')") FROM "stock prices"
#         WHERE "('Date', '')" BETWEEN '{start_date}' AND '{end_date}'
#         """
#         avg_nifty_close = pd.read_sql_query(sql_nifty_avg, conn).iloc[0,0]
#         st.write(f"Average NIFTY Closing Price: ${avg_nifty_close:,.2f}" if avg_nifty_close else "N/A")
# 
#         st.subheader('Daily Market Snapshot')
#         sql_snapshot = f"""
#         SELECT
#             sp."('Date', '')" AS Date,
#             cp_btc.price AS Bitcoin_Price,
#             op.Price AS Oil_Price_USD,
#             sp."('^GSPC', 'Close')" AS SP500_Close,
#             sp."('^NSEI', 'Close')" AS NIFTY_Close
#         FROM "stock prices" AS sp
#         LEFT JOIN "oil prices" AS op ON sp."('Date', '')" = op.Date
#         LEFT JOIN "Crypto prices" AS cp_btc ON sp."('Date', '')" = cp_btc.date AND cp_btc.coin_name = 'bitcoin'
#         WHERE sp."('Date', '')" BETWEEN '{start_date}' AND '{end_date}'
#         ORDER BY Date;
#         """
#         market_snapshot_df = pd.read_sql_query(sql_snapshot, conn)
#         st.dataframe(market_snapshot_df)
# 
# elif select == 'SQL QUERY RUNNER':
#     st.header('SQL QUERY RUNNER: SQL Query Runner')
# 
#     predefined_queries = {
#         'Top 3 Cryptocurrencies by Market Cap': "SELECT id, name, market_cap_rank, market_cap FROM Cryptocurrency ORDER BY market_cap DESC LIMIT 3;",
#         'Cryptocurrencies with >90% Circulating Supply': "SELECT id, name, symbol, circulating_supply, total_supply FROM Cryptocurrency WHERE circulating_supply > (total_supply * 0.9) ORDER BY name;",
#         'Average Oil Price by Year': "SELECT STRFTIME('%Y', Date) AS year, AVG(Price) AS average_price FROM \"oil prices\" GROUP BY year ORDER BY year;",
#         'Highest NASDAQ Closing Price': "SELECT MAX(\"('^IXIC', 'Close')\") AS highest_close_price FROM \"stock prices\";",
#         'Correlation: Bitcoin vs S&P 500': "SELECT cp.date AS crypto_date, cp.price AS bitcoin_price, sp.\"('Date', '')\" AS stock_date, sp.\"('^GSPC', 'Close')\" AS gspc_close FROM \"Crypto prices\" AS cp INNER JOIN \"stock prices\" AS sp ON cp.date = sp.\"('Date', '')\" WHERE cp.coin_name = 'bitcoin';"
#     }
# 
#     selected_query_name = st.selectbox(
#         'Select a SQL Query to Run:',
#         list(predefined_queries.keys())
#     )
# 
#     if st.button('Run Query'):
#         query = predefined_queries[selected_query_name]
#         st.code(query, language='sql') # Display the query being run
#         try:
#             result_df = pd.read_sql_query(query, conn)
#             if not result_df.empty:
#                 st.subheader('Query Results:')
#                 st.dataframe(result_df)
#             else:
#                 st.write('No results found for this query.')
#         except Exception as e:
#             st.error(f"Error executing query: {e}")
# 
# elif select == 'TOP COINS TREND ANALYSIS':
#     st.header('TOP COINS TREND ANALYSIS: Top Cryptocurrencies Analysis')
# 
#     # Get top 3 cryptocurrencies for selection
#     top_coins_query = "SELECT id, name FROM Cryptocurrency ORDER BY market_cap_rank ASC LIMIT 3;"
#     top_coins_df = pd.read_sql_query(top_coins_query, conn)
# 
#     if not top_coins_df.empty:
#         coin_names = top_coins_df['name'].tolist()
#         selected_coin_name = st.selectbox('Select Cryptocurrency:', coin_names)
#         selected_coin_id = top_coins_df[top_coins_df['name'] == selected_coin_name]['id'].iloc[0]
# 
#         st.subheader(f'Analysis for {selected_coin_name}')
# 
#         # Date Range Selection for Page 3
#         col3, col4 = st.columns(2)
#         with col3:
#             start_date_crypto = st.date_input('Start Date', pd.to_datetime('2025-02-01'), key='p3_start_date')
#         with col4:
#             end_date_crypto = st.date_input('End Date', pd.to_datetime('2026-02-04'), key='p3_end_date')
# 
#         if start_date_crypto > end_date_crypto:
#             st.error('Error: End Date must be after Start Date.')
#         else:
#             # Fetch daily prices for the selected crypto and date range
#             sql_crypto_prices = f"""
#             SELECT date, price FROM "Crypto prices"
#             WHERE coin_name = '{selected_coin_id}' AND date BETWEEN '{start_date_crypto}' AND '{end_date_crypto}'
#             ORDER BY date;
#             """
#             daily_prices_df = pd.read_sql_query(sql_crypto_prices, conn)
#             daily_prices_df['date'] = pd.to_datetime(daily_prices_df['date'])
#             daily_prices_df = daily_prices_df.set_index('date')
# 
#             if not daily_prices_df.empty:
#                 st.subheader('Daily Price Trend')
#                 st.line_chart(daily_prices_df['price'])
# 
#                 st.subheader('Daily Price Table')
#                 st.dataframe(daily_prices_df)
#             else:
#                 st.write(f'No historical price data available for {selected_coin_name} in the selected date range.')
#     else:
#         st.write('No top cryptocurrencies found in the database.')
# 
# 
# # Close the connection when the app is done
# conn.close()

!pip install -q streamlit
!wget https://github.com/cloudflare/cloudflared/releases/latest/download/cloudflared-linux-amd64
!chmod +x cloudflared-linux-amd64
import subprocess
subprocess.Popen(["./cloudflared-linux-amd64", "tunnel", "--url", "http://localhost:8501"])
!nohup /content/cloudflared-linux-amd64 tunnel --url http://localhost:8501 &

!streamlit run /content/app.py &>/content/logs.txt &  # here instead of app.py please rename with your file name

!grep -o 'https://.*\.trycloudflare.com' nohup.out | head -n 1 | xargs -I {} echo "Your tunnel url {}"

!jupyter nbconvert Untitled10.ipynb --to python
from google.colab import files
files.download('Untitled10.py')